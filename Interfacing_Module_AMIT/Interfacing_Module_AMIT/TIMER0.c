/*
 * TIMER0.c
 *
 * Created: 04/12/2020 08:37:35 م
 *  Author: magdy
 */ 
#include "TIMER0.h"

Uint32t NUM_OVF = 0;
Uint32t INITIAL_VALUE = 0;

void TIMER0_INIT(void)
{
	#if WAVE_GENERATION_MODE == NORMAL_MODE
	CLR_BIT(TCCR0, WGM00); CLR_BIT(TCCR0, WGM01);
	SET_BIT(TIMSK, TOIE0); //ENABLE PREPHERAL INTERRUPT
	#elif WAVE_GENERATION_MODE == PHASE_CORRECT_PWM
	CLR_BIT(TCCR0, WGM01); SET_BIT(TCCR0, WGM00);
	#elif WAVE_GENERATION_MODE == CTC_MODE
	SET_BIT(TCCR0, WGM01); CLR_BIT(TCCR0, WGM00);
	SET_BIT(TIMSK, OCIE0); //ENABLE PREPHERAL INTERRUPT
	#elif WAVE_GENERATION_MODE == FAST_PWM
	SET_BIT(TCCR0, WGM01); SET_BIT(TCCR0, WGM00);
	#else
	#warning "wrong mode for timer0"
	#endif
	SET_BIT(SREG, 7);
}
void TIMER0_START(void)
{
	#if TIMER0_PRESCALAR == CLK_1024
	SET_BIT(TCCR0, CS02); CLR_BIT(TCCR0, CS01); SET_BIT(TCCR0, CS00);
    #endif
}
void TIMER0_STOP(void)
{
	#if TIMER0_PRESCALAR == NO_CLK
	CLR_BIT(TCCR0, SC02); CLR_BIT(TCCR0, CS01); CLR_BIT(TCCR0, CS00);
	#endif
}
void TIMER0_SET_DELAY(Uint32t Delay_ms, Uint8t TOP)
{
	#if WAVE_GENERATION_MODE == NORMAL_MODE
	Uint8t Tick = 1024/16;
	Uint32t Total_OVF = (Delay_ms * 1000) / Tick;
	NUM_OVF = Total_OVF / 256;
	INITIAL_VALUE = 256 - (Total_OVF % 256);
	TCNT0 = INITIAL_VALUE;
	NUM_OVF ++;
	#elif WAVE_GENERATION_MODE == CTC_MODE
	Uint8t Tick = 1024/16;
	Uint32t Total_OVF = (Delay_ms * 1000) / Tick;
	OCR0 = TOP;
	NUM_OVF = Total_OVF / OCR0;
	NUM_OVF ++;
	#endif
}
void TIMER0_FASTPWM_INIT(void){
	
SET_BIT(DDRB, PB3);
SET_BIT(TCCR0, COM01); CLR_BIT(TCCR0, COM00);
SET_BIT(TCCR0, WGM01); SET_BIT(TCCR0, WGM00);	
}

void TIMER0_FASTPWM_SetDutyCycle(Uint8t Duty_Cycle)
{
	
	OCR0 = ((256 * Duty_Cycle) /100) - 1;
}
void TIMER0_FASTPWM_START(void)
{
	SET_BIT(TCCR0, CS02); CLR_BIT(TCCR0, CS01); CLR_BIT(TCCR0, CS00);
}
void TIMER0_FASTPWM_STOP(void)
{
	CLR_BIT(TCCR0, CS02); CLR_BIT(TCCR0, CS01); CLR_BIT(TCCR0, CS00);
}

